diff -urN stock/arch/arm/mach-msm/acpuclock-arm11.c overclock/arch/arm/mach-msm/acpuclock-arm11.c
--- stock/arch/arm/mach-msm/acpuclock-arm11.c	2010-04-21 06:07:37.000000000 -0700
+++ overclock/arch/arm/mach-msm/acpuclock-arm11.c	2010-05-10 13:55:04.000000000 -0700
@@ -98,6 +98,15 @@
 /* Index in acpu_freq_tbl[] for steppings. */
 	short		down;
 	short		up;
+	unsigned long	pllclk_mul;
+};
+
+/* table of multiplier addresses, per pll */
+static void *acpu_pll_mul_addr[] = {
+	MSM_CLK_CTL_BASE+0x304, /* PLL0 (mpll)  */
+	MSM_CLK_CTL_BASE+0x320, /* PLL1 (gpll)  */
+	MSM_CLK_CTL_BASE+0x33c, /* PLL2 (bpll0) */
+	MSM_CLK_CTL_BASE+0x358, /* PLL3 (bpll1) */
 };
 
 /*
@@ -126,21 +135,31 @@
 static struct clkctl_acpu_speed  msm72xx_tbl[] = {
 #if defined(CONFIG_TURBO_MODE)
 	{ 19200, ACPU_PLL_TCXO, 0, 0, 19200, 0, VDD_0, 30720, 0, 0, 4 },
-	{ 122880, ACPU_PLL_0, 4, 1, 61440, 1, VDD_3, 61440, 0, 0, 4 },
+	{ 122880, ACPU_PLL_0, 4, 1, 61440, 1, VDD_3, 61440, 0, 0, 4, 10 },
 #if 1 /* QCT fixup */
-	{ 160000, ACPU_PLL_1, 1, 5, 53333, 2, VDD_3, 61440, 0, 0, 6 },
+	{ 160000, ACPU_PLL_1, 1, 5, 53333, 2, VDD_3, 61440, 0, 0, 6, 50 },
 #else /* Google */
-	{ 160000, ACPU_PLL_1, 1, 5, 64000, 1, VDD_3, 61440, 0, 0, 6 },
+	{ 160000, ACPU_PLL_1, 1, 5, 64000, 1, VDD_3, 61440, 0, 0, 6, 50 },
 #endif
-	{ 176000, ACPU_PLL_2, 2, 5, 88000, 1, VDD_3, 61440, 0, 0, 5 },
-	{ 245760, ACPU_PLL_0, 4, 0, 81920, 2, VDD_4, 61440, 0, 0, 5 },
-	{ 352000, ACPU_PLL_2, 2, 2, 88000, 3, VDD_5, 128000, 0, 3, 7 },
+	{ 176000, ACPU_PLL_2, 2, 5, 88000, 1, VDD_3, 61440, 0, 0, 5, 55 },
+	{ 245760, ACPU_PLL_0, 4, 0, 81920, 2, VDD_4, 61440, 0, 0, 5, 10 },
+	{ 352000, ACPU_PLL_2, 2, 2, 88000, 3, VDD_5, 128000, 0, 3, 7, 55 },
 #if 1 /* QCT fixup */
-	{ 480000, ACPU_PLL_1, 1, 1, 120000, 3, VDD_6, 120000, 0, 2, -1 },
+	{ 480000, ACPU_PLL_1, 1, 1, 120000, 3, VDD_6, 120000, 0, 2, 7, 50 },
 #else /* Google */
-	{ 480000, ACPU_PLL_1, 1, 1, 128000, 2, VDD_6, 160000, 0, 2, -1 },
+	{ 480000, ACPU_PLL_1, 1, 1, 128000, 2, VDD_6, 160000, 0, 2, 7, 50 },
 #endif
-	{ 528000, ACPU_PLL_2, 2, 1, 132000, 3, VDD_7, 160000, 0, 5, -1 },
+	{ 528000, ACPU_PLL_2, 2, 1, 132000, 3, VDD_7, 160000, 0, 5, 12, 55 },
+	{ 604800, ACPU_PLL_2, 2, 1, 151200, 3, VDD_7, 160000, 0, 7, 12, 63 },
+	{ 710400, ACPU_PLL_2, 2, 0, 156000, 3, VDD_7, 160000, 0, 7, -1, 37 },
+	{ 729600, ACPU_PLL_2, 2, 0, 160800, 3, VDD_7, 160000, 0, 7, -1, 38 },
+	{ 748800, ACPU_PLL_2, 2, 0, 187200, 3, VDD_7, 160000, 0, 7, -1, 39 },
+	{ 768000, ACPU_PLL_2, 2, 0, 192000, 3, VDD_7, 160000, 0, 7, -1, 40 },
+	{ 787200, ACPU_PLL_2, 2, 0, 196800, 3, VDD_7, 160000, 0, 12, -1, 41 },
+	{ 806400, ACPU_PLL_2, 2, 0, 201600, 3, VDD_7, 160000, 0, 12, -1, 42 },
+	{ 825600, ACPU_PLL_2, 2, 0, 201600, 3, VDD_7, 160000, 0, 12, -1, 43 },
+	{ 844800, ACPU_PLL_2, 2, 0, 201600, 3, VDD_7, 160000, 0, 12, -1, 44 },
+	{ 864000, ACPU_PLL_2, 2, 0, 201600, 3, VDD_7, 160000, 0, 12, -1, 45 },
 	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
 #else
 	{ 19200, ACPU_PLL_TCXO, 0, 0, 19200, 0, VDD_0, 30720, 0, 0, 4 },
@@ -175,7 +194,17 @@
 	{ 3, 245760 },
 	{ 4, 480000 },
 	{ 5, 528000 },
-	{ 6, CPUFREQ_TABLE_END },
+	{ 6, 604800 },
+	{ 7, 710400 },
+	{ 8, 729600 },
+	{ 9, 748800 },
+	{ 10, 768000 },
+	{ 11, 787200 },
+	{ 12, 806400 },
+	{ 13, 825600 },
+	{ 14, 844800 },
+	{ 15, 864000 },
+	{ 16, CPUFREQ_TABLE_END },
 #else
 	{ 0, 19200 },
 	{ 1, 122880 },
@@ -300,10 +329,14 @@
 
 /* Set proper dividers for the given clock speed. */
 static void acpuclk_set_div(const struct clkctl_acpu_speed *hunt_s) {
-	uint32_t reg_clkctl, reg_clksel, clk_div;
+	uint32_t reg_clkctl, reg_clksel, clk_div, pllclk_mul;
+	void *pllclk_mul_addr;
 
 	/* AHB_CLK_DIV */
 	clk_div = (readl(A11S_CLK_SEL_ADDR) >> 1) & 0x03;
+	/* PLL clock multiplier */
+	pllclk_mul_addr = hunt_s->pll >= 0 ? acpu_pll_mul_addr[hunt_s->pll] : 0;
+	pllclk_mul = pllclk_mul_addr ? readl(pllclk_mul_addr) : 0;
 	/*
 	 * If the new clock divider is higher than the previous, then
 	 * program the divider before switching the clock
@@ -332,7 +365,6 @@
 		/* Program clock source selection */
 		reg_clksel = readl(A11S_CLK_SEL_ADDR);
 		reg_clksel |= 1; /* CLK_SEL_SRC1NO  == SRC1 */
-		writel(reg_clksel, A11S_CLK_SEL_ADDR);
 	} else {
 		/* SRC1 */
 
@@ -351,9 +383,37 @@
 		/* Program clock source selection */
 		reg_clksel = readl(A11S_CLK_SEL_ADDR);
 		reg_clksel &= ~1; /* CLK_SEL_SRC1NO  == SRC0 */
-		writel(reg_clksel, A11S_CLK_SEL_ADDR);
 	}
-
+	/* 
+	 * If the new multiplier is lower than the previous, then change
+	 * the multiplier before changing the clock parameters
+	 */
+	if (pllclk_mul_addr && hunt_s->pllclk_mul < pllclk_mul) {
+		writel(hunt_s->pllclk_mul, pllclk_mul_addr);
+		udelay(drv_state.vdd_switch_time_us);
+		pllclk_mul = readl(pllclk_mul_addr);
+		if (pllclk_mul != hunt_s->pllclk_mul) {
+			pr_info("acpuclock: failed to alter PLL mult: %lu\n", 
+				hunt_s->pllclk_mul);
+			return; /* don't switch clocks on failure */
+		} 
+	}
+	/* Write clock source selection */
+	writel(reg_clksel, A11S_CLK_SEL_ADDR);
+	/* 
+	 * If the new multiplier is higher than the previous, then change
+	 * the multiplier after changing the clock parameters
+	 */
+	if (pllclk_mul_addr && hunt_s->pllclk_mul > pllclk_mul) {
+		writel(hunt_s->pllclk_mul, pllclk_mul_addr);
+		udelay(drv_state.vdd_switch_time_us);
+		pllclk_mul = readl(pllclk_mul_addr);
+		if (pllclk_mul != hunt_s->pllclk_mul) {
+			pr_info("acpuclock: failed to alter PLL mult: %lu\n", 
+				hunt_s->pllclk_mul);
+			return;
+		} 
+	}
 	/*
 	 * If the new clock divider is lower than the previous, then
 	 * program the divider after switching the clock
diff -urN stock/arch/arm/mach-msm/cpufreq.c overclock/arch/arm/mach-msm/cpufreq.c
--- stock/arch/arm/mach-msm/cpufreq.c	2010-04-21 06:07:35.000000000 -0700
+++ overclock/arch/arm/mach-msm/cpufreq.c	2010-05-10 07:23:48.000000000 -0700
@@ -20,6 +20,7 @@
 #include <linux/cpufreq.h>
 #include <linux/earlysuspend.h>
 #include <linux/init.h>
+#include <linux/cpufreq.h>
 #include "acpuclock.h"
 
 #ifdef CONFIG_MSM_CPU_FREQ_SCREEN
@@ -86,6 +87,12 @@
 	return 0;
 }
 
+static struct freq_attr* msm_attr[] = {
+        &cpufreq_freq_attr_scaling_available_freqs,
+        NULL,
+};
+
+
 static int __init msm_cpufreq_init(struct cpufreq_policy *policy)
 {
 	struct cpufreq_frequency_table *table =
@@ -93,9 +100,11 @@
 
 	BUG_ON(cpufreq_frequency_table_cpuinfo(policy, table));
 	policy->cur = acpuclk_get_rate();
-#if 0
 	/* restrict cpu freq scaling range by overwriting */
+#ifdef CONFIG_MSM_CPU_FREQ_ONDEMAND_MIN
 	policy->min = CONFIG_MSM_CPU_FREQ_ONDEMAND_MIN;
+#endif
+#ifdef CONFIG_MSM_CPU_FREQ_ONDEMAND_MAX
 	policy->max = CONFIG_MSM_CPU_FREQ_ONDEMAND_MAX;
 #endif
 	policy->cpuinfo.transition_latency =
@@ -110,6 +119,8 @@
 	.verify		= msm_cpufreq_verify,
 	.target		= msm_cpufreq_target,
 	.name		= "msm",
+	.owner		= THIS_MODULE,
+	.attr		= msm_attr,
 };
 
 static int __init msm_cpufreq_register(void)
diff -urN stock/.config overclock/.config
--- stock/.config	2010-05-10 12:43:20.000000000 -0700
+++ overclock/.config	2010-05-10 08:06:26.000000000 -0700
@@ -187,13 +187,7 @@
 CONFIG_ARCH_MSM_ARM11=y
 CONFIG_MSM_MDP22=y
 CONFIG_TURBO_MODE=y
-CONFIG_PERFLOCK=y
-CONFIG_PERFLOCK_BOOT_LOCK=y
-CONFIG_PERFLOCK_SCREEN_POLICY=y
-CONFIG_PERFLOCK_SCREEN_ON_MIN=480000
-CONFIG_PERFLOCK_SCREEN_ON_MAX=528000
-CONFIG_PERFLOCK_SCREEN_OFF_MIN=245760
-CONFIG_PERFLOCK_SCREEN_OFF_MAX=245760
+CONFIG_PERFLOCK=n
 CONFIG_MSM_AMSS_VERSION=4410
 # CONFIG_MSM_AMSS_VERSION_6210 is not set
 # CONFIG_MSM_AMSS_VERSION_6220 is not set
@@ -378,7 +372,7 @@
 # CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
 CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
 # CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
-# CONFIG_CPU_FREQ_GOV_USERSPACE is not set
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
 CONFIG_CPU_FREQ_GOV_ONDEMAND=y
 # CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
 CONFIG_CPU_FREQ_MIN_TICKS=1
@@ -537,7 +531,7 @@
 CONFIG_NETFILTER_XT_MATCH_MAC=y
 CONFIG_NETFILTER_XT_MATCH_MARK=y
 CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
-# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+CONFIG_NETFILTER_XT_MATCH_OWNER=y
 # CONFIG_NETFILTER_XT_MATCH_POLICY is not set
 CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
 CONFIG_NETFILTER_XT_MATCH_QUOTA=y
